<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Web开发之渲染性能 | Orlo Wang's Site</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="本文中的大部分内容可以在文中提供的链接中找到，本文只是做一个资源的整理。
 渲染流水线 我们通常使用javascript来实现一些视觉变换效果，这个过程可以归纳为这样一条流水线，包含五个关键步骤：
 
 如今大多数设备屏幕刷新率都是60次/ …"><meta name=generator content="Hugo 0.81.0"><meta name=ROBOTS content="INDEX, FOLLOW"><link rel=stylesheet href=/css/style.1206d5218537f13449871f3607e0bfe0cf7f596e14662f9b75da386d6fcc5f80.scss><meta property="og:title" content="Web开发之渲染性能"><meta property="og:description" content="本文中的大部分内容可以在文中提供的链接中找到，本文只是做一个资源的整理。
 渲染流水线 我们通常使用javascript来实现一些视觉变换效果，这个过程可以归纳为这样一条流水线，包含五个关键步骤：
 
 如今大多数设备屏幕刷新率都是60次/ …"><meta property="og:type" content="article"><meta property="og:url" content="/article/render-performance/"><meta property="article:section" content="article"><meta property="article:published_time" content="2019-03-29T08:47:11+01:00"><meta property="article:modified_time" content="2019-03-29T08:47:11+01:00"><meta itemprop=name content="Web开发之渲染性能"><meta itemprop=description content="本文中的大部分内容可以在文中提供的链接中找到，本文只是做一个资源的整理。
 渲染流水线 我们通常使用javascript来实现一些视觉变换效果，这个过程可以归纳为这样一条流水线，包含五个关键步骤：
 
 如今大多数设备屏幕刷新率都是60次/ …"><meta itemprop=datePublished content="2019-03-29T08:47:11+01:00"><meta itemprop=dateModified content="2019-03-29T08:47:11+01:00"><meta itemprop=wordCount content="56"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Web开发之渲染性能"><meta name=twitter:description content="本文中的大部分内容可以在文中提供的链接中找到，本文只是做一个资源的整理。
 渲染流水线 我们通常使用javascript来实现一些视觉变换效果，这个过程可以归纳为这样一条流水线，包含五个关键步骤：
 
 如今大多数设备屏幕刷新率都是60次/ …"></head><body><aside class=main><div id=theme-switcher class="switch wrapper"><label for=checkbox><input type=checkbox id=checkbox><div class="slider round"></div></label><script>const toggleSwitch=document.getElementById('theme-switcher').querySelector('input[type="checkbox"]'),currentTheme=localStorage.getItem('theme');currentTheme&&(document.documentElement.setAttribute('data-theme',currentTheme),currentTheme==='dark'&&(toggleSwitch.checked=!0));function switchTheme(a){a.target.checked?(document.documentElement.setAttribute('data-theme','dark'),localStorage.setItem('theme','dark')):(document.documentElement.setAttribute('data-theme','light'),localStorage.setItem('theme','light'))}toggleSwitch.addEventListener('change',switchTheme,!1)</script></div><div class=avatar><img src=/images/avatar.jpg alt=Author></div><h1 class=author>Orlo Wang</h1><div class=bio>人生的意义在于感受，满足感源于感受度，丰富的满足感产生幸福感，强烈的满足感产生价值感；这一切都让人生显得格外有意义。</div><a class=main href=/about/>About</a></aside><header class=main><a href=/article/><span class=icon style=width:1.4rem><svg aria-hidden="true" focusable="false" data-icon="list-ul" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M48 368a48 48 0 1048 48 48 48 0 00-48-48zm0-160a48 48 0 1048 48 48 48 0 00-48-48zm0-160a48 48 0 1048 48A48 48 0 0048 48zm448 24H176a16 16 0 00-16 16v16a16 16 0 0016 16h320a16 16 0 0016-16V88a16 16 0 00-16-16zm0 160H176a16 16 0 00-16 16v16a16 16 0 0016 16h320a16 16 0 0016-16v-16a16 16 0 00-16-16zm0 160H176a16 16 0 00-16 16v16a16 16 0 0016 16h320a16 16 0 0016-16v-16a16 16 0 00-16-16z"/></svg></span></a><span class=title style=font-size:1.4rem>Web开发之渲染性能</span>
<a href=/><span class=icon style=width:1.6rem><svg aria-hidden="true" focusable="false" data-icon="home-alt" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="currentcolor" d="M541 229.16l-232.85-190a32.16 32.16.0 00-40.38.0L35 229.16a8 8 0 00-1.16 11.24l10.1 12.41a8 8 0 0011.2 1.19L96 220.62v243a16 16 0 0016 16h128a16 16 0 0016-16v-128l64 .3V464a16 16 0 0016 16l128-.33a16 16 0 0016-16V220.62L520.86 254a8 8 0 0011.25-1.16l10.1-12.41A8 8 0 00541 229.16zm-93.11 218.59h.1l-96 .3V319.88a16.05 16.05.0 00-15.95-16l-96-.27a16 16 0 00-16.05 16v128.14H128V194.51L288 63.94l160 130.57z"/></svg></span></a></header><main role=main class=main><section id=main><aside id=meta><section><span class=info>发表于<strong>Fri, Mar 29 2019</strong> |</span>
<span class=info>56个字</span>
<span class=info>约1分钟阅读</span></section></aside><article id=content><blockquote><p>本文中的大部分内容可以在文中提供的链接中找到，本文只是做一个资源的整理。</p></blockquote><h3 id=渲染流水线>渲染流水线</h3><p>我们通常使用javascript来实现一些视觉变换效果，这个过程可以归纳为这样一条流水线，包含五个关键步骤：</p><p><div class=image style=padding-bottom:15.279048490393413%><img src=frame-full.jpg alt loading=lazy></div></p><blockquote><p>如今大多数设备屏幕刷新率都是<strong>60次/秒(60fps)</strong>，理论上说，每一帧都要经过以上流水线渲染出来，也就是说，每一帧要在16毫秒(1秒/60=16.66毫秒)内完成，但实际上，在渲染某一帧画面的同时，浏览器还有一些额外的工作要做（比如渲染队列的管理，渲染线程与其他线程之间的切换等等）。因此单纯的渲染工作，一般需要控制在10毫秒之内完成，才能达到流畅的视觉效果。如果超过了这个时间限度，页面的渲染就会出现卡顿效果，也就是常说的jank。</p></blockquote><p>如果你修改了一个DOM元素的<strong>layout</strong>属性(如宽度、高度或位置)，会激发页面的<code>reflow</code>完成重新布局，会完整的经历以上流水线；如果你修改了仅是<strong>paint only</strong>，比如背景图、字体颜色或阴影，那么会跳过布局过程。</p><p><div class=image style=padding-bottom:15.279048490393413%><img src=frame-no-layout.jpg alt loading=lazy></div></p><p>如果你修改一个非样式且非绘制的CSS属性，那么浏览器会在完成样式计算之后，跳过布局和绘制的过程，直接做渲染层合并。</p><p><div class=image style=padding-bottom:15.279048490393413%><img src=frame-no-layout-paint.jpg alt loading=lazy></div></p><p>第三种方式在性能上是最理想的，对于动画和滚动这种负荷很重的渲染，我们要争取使用第三种渲染流程。为了达到理想的渲染流水线，你需要对元素谨慎使用会被修改的样式属性，只能使用那些仅触发渲染层合并的属性。目前，只有两个属性是满足这个条件的：<code>transforms</code>和<code>opacity</code>：</p><ul><li>改变位置 - transform: translate(npx, npx);</li><li>改变缩放 - transform: scale(n);</li><li>角度旋转 - transform: rotate(ndeg);</li><li>角度倾斜 - transform: skew(X/Y)(ndeg);</li><li>矩阵变换 - transform: matrix(3d)(&mldr;);</li><li>透明度 - opacity: 0&mldr;1;</li></ul><p>应用了<code>transforms/opacity</code>属性的元素必须<strong>独占一个渲染层</strong>。为了对这个元素创建一个自有的渲染层，你必须提升该元素。下面让我看看如何把一个元素提升到单独的渲染层中。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css>.<span style=color:#a6e22e>moving-element</span> {
  <span style=color:#66d9ef>will-change</span>: <span style=color:#66d9ef>transform</span>;
}
</code></pre></div><p>对于旧版本或不支持will-change属性的浏览器：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css>.<span style=color:#a6e22e>moving-element</span> {
  <span style=color:#66d9ef>transform</span>: translateZ(<span style=color:#ae81ff>0</span>);
}
</code></pre></div><p>使用这个CSS属性能提前告知浏览器：这个元素将会执行动画效果。从而浏览器可以提前做一些准备，比如为这个元素创建一个新的渲染层。</p><p>这看上去非常诱人，以致于你准备对页面中所有元素都这么处理：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=color:#f92672>*</span> {
  <span style=color:#66d9ef>will-change</span>: <span style=color:#66d9ef>transform</span>;
  <span style=color:#66d9ef>transform</span>: translateZ(<span style=color:#ae81ff>0</span>);
}
</code></pre></div><p>上面这段代码意味着你想对页面中每个元素都创建一个自有的渲染层。问题是，创建一个新的渲染层并不是免费的，它得消耗额外的内存和管理资源。实际上，在内存资源有限的设备上，由于过多的渲染层来带的开销而对页面渲染性能产生的影响，甚至远远超过了它在性能改善上带来的好处。由于每个渲染层的纹理都需要上传到GPU处理，因此我们还需要考虑CPU和GPU之间的带宽问题、以及有多大内存供GPU处理这些纹理的问题。</p><p>简而言之，<strong>当且仅当需要的时候才为元素创建渲染层</strong>。</p></article><section class=article></section></section><aside id=meta><div></div></aside></main></body></html>